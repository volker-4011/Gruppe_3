---
title: "neuro"
author: "Peyman Farshidfar"
date: "3 6 2021"
output: html_document
---


### Installation von Python und TensorFlow (nur einmalig nötig)
```{r}
#install.packages("reticulate")
#library(reticulate)
# Installation von miniconda (falls nicht vorhanden)
#install_miniconda(update=TRUE)
# Anlegen einer speziellen Python Umgebung
#conda_create("r-reticulate", packages = "python=3.6")
# Installieren der Pakete in der angelegten Umgebung
#conda_install("r-reticulate", "pandas")
#conda_install("r-reticulate", "numpy")
#conda_install("r-reticulate", "tensorflow")
#conda_install("r-reticulate", "h5py")
 
# Verwenden der speziellen Python Umgebung die zuvor erstellt wurde
use_condaenv("r-reticulate")
```

### Aufruf des Skripts zur Datenaufbereitung
```{r, include=FALSE}
source("neural-net-data-preparation-Peyman.R", encoding = "UTF-8")
```


### Laden benötigter Packages
```{r, include=FALSE}
library(reticulate)
library(ggplot2)
library(Metrics)
```


### Definition des Neuronalen Netzes
```{python}
# Import needed Python libraries and functions
import numpy as np

#training_features = np.asarray(training_features)
#training_labels = np.asarray(training_labels)
#validation_features = np.asarray(validation_features)
#validation_labels = np.asarray(validation_labels)
#test_features = np.asarray(test_features)
#test_labels = np.asarray(test_labels)

#training_features = np.array(training_features)
#training_labels = np.array(training_labels)
#validation_features = np.array(validation_features)
#validation_labels = np.array(validation_labels)
#test_features = np.array(test_features)
#test_labels = np.array(test_labels)


import tensorflow as tf
from tensorflow.keras.layers import Dense
from tensorflow.keras.optimizers import Adam
from tensorflow.keras.layers.experimental import preprocessing





# Create a Normalization layer and use the means and variances of the training features for the normalization
normalizer = preprocessing.Normalization()
normalizer.adapt(r.training_features.values)
# The argument "shape" for the definition of the input layer must include the number of variables (features) used for the model. To automatically calculate this number, we use the "r.training_features.keys()", which returns the list of variable names of the dataframe "training_features". Further, the function len() returns the length of this list of variable names (i.e. the number of variables in the input).
inputs = tf.keras.Input(shape=[len(r.training_features.keys())])
# Normalization layer
x = normalizer(inputs)
# 1st hidden layer
x = Dense(10, activation='relu')(x)
# 2nd hidden layer
x = Dense(4, activation='relu')(x)
# Output layer
output = tf.keras.layers.Dense(1)(x)
# Model definition
model = tf.keras.Model(inputs, output)
# Ausgabe einer Zusammenfassung zur Form des Modells, das geschaetzt wird (nicht notwendig)
model.summary()
```


```{r}
str(training_features)
str(training_labels)

str(validation_features)
str(validation_labels)
```





### Schätzung des neuronalen Netzes
```{python}
# Definition der Kosten-(Loss-)Funktion und der Optimierungsfunktion mit seinen Hyperparametern
model.compile(loss="mse", optimizer=Adam(lr=0.001))
# Schaetzung des Modells
history = model.fit(r.training_features, r.training_labels, epochs=50,
                    validation_data = (r.validation_features, r.validation_labels), verbose=0)
# Ggf. Speichern des geschaetzten Modells
model.save("python_model.h5")
```


### Auswertung der Modelloptimierung
```{r}
# Grafische Ausgabe der Modelloptimierung
# create data
data <- data.frame(val_loss = unlist(py$history$history$val_loss),
                  loss = unlist(py$history$history$loss))
# Plot
ggplot(data[-1,]) +
  geom_line( aes(x=1:length(val_loss), y=val_loss, colour = "Validation Loss" )) +
  geom_line( aes(x=1:length(loss), y=loss, colour = "Training Loss" )) +
  scale_colour_manual( values = c("Training Loss"="blue", "Validation Loss"="red") ) +
  labs(title="Loss Function Values During Optimization") +
  xlab("Iteration Number") +
  ylab("Loss") 
```


### (Ggf.) Laden eines gespeicherten Neuronalen Netzes ###
```{python}
model = tf.keras.models.load_model("python_model.h5")
```


### Auswertung der Schätzergebnisse ###
```{r}
# Schätzung der (normierten) Preise für die Trainings- und Testdaten
training_predictions <- py$model$predict(training_features)
validation_predictions <- py$model$predict(validation_features)
# Vergleich der Gütekriterien für die Traingings- und Testdaten
cat(paste0("MAPE on the Training Data:\t", format(mape(training_labels[[1]], training_predictions)*100, digits=3, nsmall=2)))
cat(paste0("\nMAPE on the Validation Data:\t", format(mape(validation_labels[[1]], validation_predictions)*100, digits=3, nsmall=2)))
```

```{r}
## Grafischer vergleich der vorhergesagten und der tatsächlichen Preise für die Trainings- und Testdaten
# Zusammenstellung der Daten für die Plots
data_train <- data.frame(prediction = training_predictions/1000, actual = training_labels[[1]]/1000)
data_test <- data.frame(prediction = validation_predictions/1000, actual = validation_labels[[1]]/1000)
# Plot der Ergebnisse der Trainingsdaten
ggplot(data_train[1:100,]) +
  geom_line( aes(x=1:length(prediction), y=prediction, colour = "Predicted Values" )) +
  geom_line( aes(x=1:length(actual), y=actual, colour = "Actual Values" )) +
  scale_colour_manual( values = c("Predicted Values"="blue", "Actual Values"="red") ) +
  labs(title="Predicted and Actual Values for the Training Data") +
  xlab("Case Number") +
  ylab("Price in 1.000 USD") 
# Plot der Ergebnisse der Validierungsdaten
ggplot(data_test[1:100,]) +
  geom_line( aes(x=1:length(prediction), y=prediction, colour = "Predicted Values" )) +
  geom_line( aes(x=1:length(actual), y=actual, colour = "Actual Values" )) +
  scale_colour_manual( values = c("Predicted Values"="blue", "Actual Values"="red") ) +
  labs(title="Predicted and Actual Values for the Test Data") +
  xlab("Case Number") +
  ylab("Price in 1.000 USD") 
```

```{r}
# Vorhersage für einen einzelnen Fall
cat(paste0("Vorhergesagter Umsatz:\t", round(validation_predictions[100])))
cat(paste0("\nTatsächlicher Umsatz:\t", validation_labels[[1]][100]))
```